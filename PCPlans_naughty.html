<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>PCPlans_naughty</title><link rel="stylesheet" href="Agda.css"></head><body><pre>
<a id="88" class="Keyword">module</a> <a id="95" href="PCPlans_naughty.html" class="Module Operator">PCPlans_naughty</a> <a id="111" class="Keyword">where</a>

<a id="118" class="Keyword">open</a> <a id="123" class="Keyword">import</a> <a id="130" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
<a id="168" class="Keyword">open</a> <a id="173" class="Keyword">import</a> <a id="180" href="Relation.Binary.html" class="Module">Relation.Binary</a>
<a id="196" class="Keyword">open</a> <a id="201" class="Keyword">import</a> <a id="208" href="Data.List.html" class="Module">Data.List</a>
<a id="218" class="Keyword">open</a> <a id="223" class="Keyword">import</a> <a id="230" href="Data.List.Any.html" class="Module">Data.List.Any</a>
<a id="244" class="Keyword">open</a> <a id="249" class="Keyword">import</a> <a id="256" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="273" class="Keyword">using</a> <a id="279" class="Symbol">(</a><a id="280" href="Relation.Nullary.html#570" class="InductiveConstructor">yes</a><a id="283" class="Symbol">;</a> <a id="285" href="Relation.Nullary.html#597" class="InductiveConstructor">no</a><a id="287" class="Symbol">;</a> <a id="289" href="Relation.Nullary.html#534" class="Datatype">Dec</a><a id="292" class="Symbol">)</a>
<a id="294" class="Keyword">open</a> <a id="299" class="Keyword">import</a> <a id="306" href="Level.html" class="Module">Level</a>

<a id="313" class="Comment">--------------------------------------------------------</a>
<a id="370" class="Comment">-- A simple example that demonstrates violation of the</a>
<a id="425" class="Comment">-- implicit consistency assumpion</a>
<a id="459" class="Comment">--</a>

<a id="463" class="Comment">-- We don&#39;t need any constants</a>
<a id="494" class="Keyword">data</a> <a id="C"></a><a id="499" href="PCPlans_naughty.html#499" class="Datatype">C</a> <a id="501" class="Symbol">:</a> <a id="503" class="PrimitiveType">Set</a> <a id="507" class="Keyword">where</a>

<a id="514" class="Comment">-- Predicates</a>
<a id="528" class="Keyword">data</a> <a id="R"></a><a id="533" href="PCPlans_naughty.html#533" class="Datatype">R</a> <a id="535" class="Symbol">:</a> <a id="537" class="PrimitiveType">Set</a> <a id="541" class="Keyword">where</a>
  <a id="R.handEmpty"></a><a id="549" href="PCPlans_naughty.html#549" class="InductiveConstructor">handEmpty</a> <a id="559" class="Symbol">:</a> <a id="561" href="PCPlans_naughty.html#533" class="Datatype">R</a>

<a id="564" class="Comment">-- There is only one, naughty, action, which violates the implicit</a>
<a id="631" class="Comment">-- consistency assumption </a>
<a id="658" class="Keyword">data</a> <a id="Action"></a><a id="663" href="PCPlans_naughty.html#663" class="Datatype">Action</a> <a id="670" class="Symbol">:</a> <a id="672" class="PrimitiveType">Set</a> <a id="676" class="Keyword">where</a> 
  <a id="Action.naughty"></a><a id="685" href="PCPlans_naughty.html#685" class="InductiveConstructor">naughty</a> <a id="693" class="Symbol">:</a> <a id="695" href="PCPlans_naughty.html#663" class="Datatype">Action</a>

<a id="703" class="Comment">-- The following two properties are required by the main Agda file:</a>

<a id="772" class="Comment">-- Decidablity of constants (objects) -- </a>
<a id="_≡o?_"></a><a id="814" href="PCPlans_naughty.html#814" class="Function Operator">_≡o?_</a> <a id="820" class="Symbol">:</a> <a id="822" href="Relation.Binary.Core.html#4499" class="Function">Decidable</a> <a id="832" class="Symbol">(</a><a id="833" href="Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a> <a id="837" class="Symbol">{</a><a id="838" class="Argument">A</a> <a id="840" class="Symbol">=</a> <a id="842" href="PCPlans_naughty.html#499" class="Datatype">C</a><a id="843" class="Symbol">})</a>
<a id="846" class="Symbol">()</a> <a id="849" href="PCPlans_naughty.html#814" class="Function Operator">≡o?</a> <a id="853" class="Symbol">()</a>

<a id="857" class="Comment">-- Decidability of predicates</a>
<a id="_≡?_"></a><a id="887" href="PCPlans_naughty.html#887" class="Function Operator">_≡?_</a> <a id="892" class="Symbol">:</a> <a id="894" href="Relation.Binary.Core.html#4499" class="Function">Decidable</a> <a id="904" class="Symbol">(</a><a id="905" href="Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a> <a id="909" class="Symbol">{</a><a id="910" class="Argument">A</a> <a id="912" class="Symbol">=</a> <a id="914" href="PCPlans_naughty.html#533" class="Datatype">R</a><a id="915" class="Symbol">})</a>
<a id="918" href="PCPlans_naughty.html#549" class="InductiveConstructor">handEmpty</a> <a id="928" href="PCPlans_naughty.html#887" class="Function Operator">≡?</a> <a id="931" href="PCPlans_naughty.html#549" class="InductiveConstructor">handEmpty</a> <a id="941" class="Symbol">=</a> <a id="943" href="Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="947" href="Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>


<a id="954" class="Comment">-- Instatiation of decidability of predicates to the IsDecEquivalence type</a>
<a id="isDecidable"></a><a id="1029" href="PCPlans_naughty.html#1029" class="Function">isDecidable</a> <a id="1041" class="Symbol">:</a> <a id="1043" href="Relation.Binary.html#2772" class="Record">IsDecEquivalence</a> <a id="1060" class="Symbol">{</a><a id="1061" href="Agda.Primitive.html#611" class="Primitive">zero</a><a id="1065" class="Symbol">}</a> <a id="1067" class="Symbol">{</a><a id="1068" href="Agda.Primitive.html#611" class="Primitive">zero</a><a id="1072" class="Symbol">}</a> <a id="1074" class="Symbol">(</a><a id="1075" href="Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a> <a id="1079" class="Symbol">{</a><a id="1080" class="Argument">A</a> <a id="1082" class="Symbol">=</a> <a id="1084" href="PCPlans_naughty.html#533" class="Datatype">R</a><a id="1085" class="Symbol">})</a>
<a id="1088" href="PCPlans_naughty.html#1029" class="Function">isDecidable</a> <a id="1100" class="Symbol">=</a> <a id="1102" class="Keyword">record</a> <a id="1109" class="Symbol">{</a> <a id="1111" class="Field">isEquivalence</a> <a id="1125" class="Symbol">=</a> <a id="1127" class="Keyword">record</a> <a id="1134" class="Symbol">{</a>
  <a id="1138" class="Field">refl</a> <a id="1143" class="Symbol">=</a> <a id="1145" class="Symbol">λ</a> <a id="1147" class="Symbol">{</a><a id="1148" href="PCPlans_naughty.html#1148" class="Bound">x</a><a id="1149" class="Symbol">}</a> <a id="1151" class="Symbol">→</a> <a id="1153" href="Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="1158" class="Symbol">;</a>
  <a id="1162" class="Field">sym</a> <a id="1166" class="Symbol">=</a> <a id="1168" class="Symbol">λ</a> <a id="1170" href="PCPlans_naughty.html#1170" class="Bound">x</a> <a id="1172" class="Symbol">→</a> <a id="1174" href="Relation.Binary.PropositionalEquality.Core.html#560" class="Function">sym</a> <a id="1178" href="PCPlans_naughty.html#1170" class="Bound">x</a> <a id="1180" class="Symbol">;</a>
  <a id="1184" class="Field">trans</a> <a id="1190" class="Symbol">=</a> <a id="1192" href="Relation.Binary.PropositionalEquality.Core.html#627" class="Function">trans</a> <a id="1198" class="Symbol">}</a> <a id="1200" class="Symbol">;</a>
  <a id="1204" class="Field Operator">_≟_</a> <a id="1208" class="Symbol">=</a> <a id="1210" href="PCPlans_naughty.html#887" class="Function Operator">_≡?_</a>  <a id="1216" class="Symbol">}</a>


<a id="1220" class="Comment">-- Instantiation of module PCPlans</a>
<a id="1255" class="Comment">-- PCPlans is parameterised by the Action Set, Predicate Set</a>
<a id="1316" class="Comment">-- as well as a proof showing that the Predicate Set is decidable</a>
<a id="1382" class="Keyword">open</a> <a id="1387" class="Keyword">import</a> <a id="1394" href="PCPlans.html" class="Module">PCPlans</a> <a id="1402" class="Symbol">{</a><a id="1403" href="PCPlans_naughty.html#663" class="Datatype">Action</a><a id="1409" class="Symbol">}</a> <a id="1411" class="Symbol">{</a><a id="1412" href="PCPlans_naughty.html#533" class="Datatype">R</a><a id="1413" class="Symbol">}</a> <a id="1415" class="Symbol">{</a><a id="1416" href="PCPlans_naughty.html#1029" class="Function">isDecidable</a><a id="1427" class="Symbol">}</a>
<a id="1429" class="Keyword">open</a> <a id="1434" class="Keyword">import</a> <a id="1441" href="Data.Product.html" class="Module">Data.Product</a>
  
<a id="1457" class="Comment">--------------------------------------------------------</a>

<a id="1515" class="Comment">-- The naughty action does not have any preconditions and</a>
<a id="1573" class="Comment">-- introduces an atomic predicate and its negation as </a>
<a id="1628" class="Comment">-- postconditions</a>
<a id="Γ₁"></a><a id="1646" href="PCPlans_naughty.html#1646" class="Function">Γ₁</a> <a id="1649" class="Symbol">:</a> <a id="1651" href="PCPlans.html#13146" class="Function">Γ</a>
<a id="1653" href="PCPlans_naughty.html#1646" class="Function">Γ₁</a> <a id="1656" href="PCPlans_naughty.html#685" class="InductiveConstructor">naughty</a>  <a id="1665" class="Symbol">=</a> <a id="1667" class="Symbol">(</a> <a id="1669" href="Agda.Builtin.List.html#117" class="InductiveConstructor">[]</a> <a id="1672" href="Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a>  <a id="1675" class="Symbol">((</a><a id="1677" href="PCPlans.html#1076" class="InductiveConstructor">-</a> <a id="1679" href="Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="1681" href="PCPlans_naughty.html#549" class="InductiveConstructor">handEmpty</a><a id="1690" class="Symbol">)</a> <a id="1692" href="Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a>  <a id="1695" class="Symbol">(</a><a id="1696" href="PCPlans.html#1074" class="InductiveConstructor">+</a> <a id="1698" href="Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="1700" href="PCPlans_naughty.html#549" class="InductiveConstructor">handEmpty</a><a id="1709" class="Symbol">)</a> <a id="1711" href="Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="1713" href="Agda.Builtin.List.html#117" class="InductiveConstructor">[]</a><a id="1715" class="Symbol">))</a>

<a id="1719" class="Keyword">open</a> <a id="1724" class="Keyword">import</a> <a id="1731" href="Data.Empty.html" class="Module">Data.Empty</a>

<a id="1743" class="Comment">-- Despite the obvious inconsistency,</a>
<a id="1781" class="Comment">-- the following plan has a derivation that type checks:</a>
<a id="plan2"></a><a id="1838" href="PCPlans_naughty.html#1838" class="Function">plan2</a> <a id="1844" class="Symbol">:</a> <a id="1846" href="PCPlans.html#12991" class="Datatype">Plan</a>
<a id="1851" href="PCPlans_naughty.html#1838" class="Function">plan2</a> <a id="1857" class="Symbol">=</a> <a id="1859" href="PCPlans.html#13010" class="InductiveConstructor">doAct</a> <a id="1865" href="PCPlans_naughty.html#685" class="InductiveConstructor">naughty</a> <a id="1873" class="Symbol">(</a><a id="1874" href="PCPlans.html#13041" class="InductiveConstructor">halt</a><a id="1878" class="Symbol">)</a>

<a id="Q"></a><a id="1881" href="PCPlans_naughty.html#1881" class="Function">Q</a> <a id="1883" class="Symbol">:</a> <a id="1885" href="PCPlans.html#798" class="Datatype">Form</a>
<a id="1890" href="PCPlans_naughty.html#1881" class="Function">Q</a> <a id="1892" class="Symbol">=</a>  <a id="1895" href="PCPlans.html#861" class="InductiveConstructor">atom</a> <a id="1900" class="Symbol">(</a><a id="1901" href="PCPlans_naughty.html#549" class="InductiveConstructor">handEmpty</a><a id="1910" class="Symbol">)</a> <a id="1912" href="PCPlans.html#817" class="InductiveConstructor Operator">∧</a>  <a id="1915" href="PCPlans.html#844" class="InductiveConstructor Operator">¬</a> <a id="1917" href="PCPlans_naughty.html#549" class="InductiveConstructor">handEmpty</a> 

<a id="Derivation2"></a><a id="1929" href="PCPlans_naughty.html#1929" class="Function">Derivation2</a> <a id="1941" class="Symbol">:</a> <a id="1943" href="PCPlans_naughty.html#1646" class="Function">Γ₁</a> <a id="1946" href="PCPlans.html#15322" class="Datatype Operator">⊢</a> <a id="1948" href="PCPlans_naughty.html#1838" class="Function">plan2</a> <a id="1954" href="PCPlans.html#15322" class="Datatype Operator">∶</a> <a id="1956" href="Agda.Builtin.List.html#117" class="InductiveConstructor">[]</a> <a id="1959" href="PCPlans.html#15322" class="Datatype Operator">↝</a> <a id="1961" class="Symbol">(</a><a id="1962" href="PCPlans_naughty.html#1881" class="Function">Q</a> <a id="1964" href="PCPlans.html#1843" class="Function Operator">↓[</a> <a id="1967" href="PCPlans.html#1074" class="InductiveConstructor">+</a> <a id="1969" href="PCPlans.html#1843" class="Function Operator">]</a> <a id="1971" href="Agda.Builtin.List.html#117" class="InductiveConstructor">[]</a><a id="1973" class="Symbol">)</a>
<a id="1975" href="PCPlans_naughty.html#1929" class="Function">Derivation2</a> <a id="1987" class="Symbol">=</a> <a id="1989" href="PCPlans.html#15420" class="InductiveConstructor">seq</a> <a id="1993" class="Symbol">(</a><a id="1994" href="PCPlans.html#13363" class="InductiveConstructor Operator">[]&lt;:</a> <a id="1999" href="Agda.Builtin.List.html#117" class="InductiveConstructor">[]</a><a id="2001" class="Symbol">)</a> <a id="2003" href="Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="2008" class="Symbol">(</a><a id="2009" href="PCPlans.html#15371" class="InductiveConstructor">halt</a> <a id="2014" class="Symbol">(</a><a id="2015" href="PCPlans.html#13387" class="InductiveConstructor">atom&lt;:</a> <a id="2022" class="Symbol">(</a><a id="2023" href="Data.List.Any.html#799" class="InductiveConstructor">here</a> <a id="2028" href="Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="2032" class="Symbol">)</a>
  <a id="2036" class="Symbol">(</a><a id="2037" href="PCPlans.html#13387" class="InductiveConstructor">atom&lt;:</a> <a id="2044" class="Symbol">(</a><a id="2045" href="Data.List.Any.html#852" class="InductiveConstructor">there</a> <a id="2051" class="Symbol">(</a><a id="2052" href="Data.List.Any.html#799" class="InductiveConstructor">here</a> <a id="2057" href="Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="2061" class="Symbol">))</a>
    <a id="2068" class="Symbol">(</a><a id="2069" href="PCPlans.html#13363" class="InductiveConstructor Operator">[]&lt;:</a> <a id="2074" class="Symbol">((</a><a id="2076" href="PCPlans.html#1076" class="InductiveConstructor">-</a> <a id="2078" href="Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="2080" href="PCPlans_naughty.html#549" class="InductiveConstructor">handEmpty</a><a id="2089" class="Symbol">)</a> <a id="2091" href="Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="2093" class="Symbol">(</a><a id="2094" href="PCPlans.html#1074" class="InductiveConstructor">+</a> <a id="2096" href="Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="2098" href="PCPlans_naughty.html#549" class="InductiveConstructor">handEmpty</a><a id="2107" class="Symbol">)</a> <a id="2109" href="Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="2111" href="Agda.Builtin.List.html#117" class="InductiveConstructor">[]</a><a id="2113" class="Symbol">)))))</a>

<a id="2120" class="Comment">-- But, at the same time, action naughty</a>
<a id="2161" class="Comment">-- invalidates consistency of entire development</a>
<a id="2210" class="Comment">-- (given the implicit consistency assumption):</a>
<a id="prop-inconsistent"></a><a id="2258" href="PCPlans_naughty.html#2258" class="Function">prop-inconsistent</a> <a id="2276" class="Symbol">:</a> <a id="2278" href="Data.Empty.html#243" class="Datatype">⊥</a>
<a id="2280" href="PCPlans_naughty.html#2258" class="Function">prop-inconsistent</a> <a id="2298" class="Symbol">=</a>
  <a id="2302" href="PCPlans.html#18145" class="Function">implicit-consistency-assumption</a> <a id="2334" href="PCPlans.html#1074" class="InductiveConstructor">+</a> <a id="2336" href="PCPlans_naughty.html#549" class="InductiveConstructor">handEmpty</a> <a id="2346" class="Symbol">(</a><a id="2347" href="Agda.Builtin.Sigma.html#167" class="Field">proj₂</a> <a id="2353" class="Symbol">(</a><a id="2354" href="PCPlans_naughty.html#1646" class="Function">Γ₁</a> <a id="2357" href="PCPlans_naughty.html#685" class="InductiveConstructor">naughty</a><a id="2364" class="Symbol">))</a>
    <a id="2371" class="Symbol">(</a><a id="2372" href="Data.List.Any.html#852" class="InductiveConstructor">there</a> <a id="2378" class="Symbol">(</a><a id="2379" href="Data.List.Any.html#799" class="InductiveConstructor">here</a> <a id="2384" href="Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="2388" class="Symbol">))</a>
    <a id="2395" class="Symbol">(</a><a id="2396" href="Data.List.Any.html#799" class="InductiveConstructor">here</a> <a id="2401" href="Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="2405" class="Symbol">)</a>
</pre></body></html>
